mod random_level_worker;
mod random;

use std::collections::HashMap;
use std::fs;

fn main() {
    println!("Starting World Generation!");

    /* These variables can all be changed */
    let seed: i64 = 22407532278926;
    let world_size: i32 = 128; //Accepted values - 128, 256, 512
    let file: String = String::from("../localStorage.txt");


    let tile_map: Vec<u8> = get_tile_map(world_size, seed);

    let json_string: String = serialize_saved_game(seed, tile_map, world_size, 1);
    let _unused: String = set_saved_game_command(file, json_string);
}

/**
 * Following function accepts a world size and seed,
 * and then passes them to the world generation functionality,
 * and then returns the output as a Vec<>
 */

pub fn get_tile_map (world_size: i32, seed: i64) -> Vec<u8> {
    let y: i32 = 64;
    let level: HashMap<usize, u8> = random_level_worker::start_generation(world_size, seed); //Generating hashmap of all tiles in the world
    let mut tile_map: Vec<u8> = Vec::new();

    for i in 0..world_size * y * world_size {
        tile_map.push(level.get(&(i as usize)).copied().unwrap_or(0)); //Copying hashmap to vec
    }

    return tile_map
}

/**
 * Following function accepts a seed, size, tilemap, and version, and creates a world save
 * in the classic javascript object format
 */
pub fn serialize_saved_game (seed: i64, tile_map: Vec<u8>, world_size: i32, version: u8) -> String {

    //Assigning x, y, and z of world
    let x: i32 = world_size;
    let y: i32 = 64;
    let z: i32 = world_size;
    let tile_map1 = get_tile_map(world_size, seed);

    let mut output: String = String::from("{"); //Opening json object

    output += &format!(r#""worldSeed":{},"#,seed.to_string()); //Adding seed key value pair

    //Adding changed blocks key value pair
    output += r#""changedBlocks":"#; //Adding blocks key
    output += "{"; //Opening block values object

    //Variables for the tiles and a value
    let mut t: u8;
    let mut t1: u8;
    let mut a: u8; //a = 0 if changed block matches generation, a = 1 if changed block does not match generation

    //Iterating through all blocks
    //Tilemaps are stored in X,Z,Y format, where [0] is X:0, Y:0, Z:0 & [1] is X:1, Y:0, Z:0 etc.
    for i in 0..y {
        for j in 0..z {
            for k in 0..x {

                /* Following code block will be more useful once a changed blocks hashmap is implemented */
               
                //Setting tile for changed block and checking whether it matches tile generated by seed
                t = tile_map[((i*z*x) + (j*x) + k) as usize];
                t1 = tile_map1[((i*z*x) + (j*x) + k) as usize];
                if t == t1 { a = 0 } else { a = 1 } //a = 0 if changed block matches generation, a = 1 if changed block does not match generation

                //Creating key for changed block
                output += &format!(r#""p{}_{}_{}":"#,k,i,j);

                //Creating value for changed block
                output += "{";
                output += &format!(r#""a":{},"bt":{}"#,a,t);
                output += "},";

            }
        }
    }

    output.pop(); //Removing extra comma
    output += "},"; //Closing Changed Blocks object

    output += &format!{r#""worldSize":{},"#,world_size}; //Adding world size key value pair
    output += &format!{r#""version":{}"#,version}; //Adding version key value pair

    output += "}"; //Closing json object
    return output;

}

/**
 * Following function excepts a file location and a world save formatted as a 
 * json string. It then creates a localStorage.setItem() command for the key
 * savedGame, in order for it to be copy pasted into a browser console to 
 * insert the world save
 */
pub fn set_saved_game_command (file: String, json_string: String) -> String {
    let open: String = String::from(r#"localStorage.setItem("savedGame", `"#); //Opening command for localStorage
    let close: String = String::from(r#"`)"#); //Closing command for localStorage

    let output: String = String::from(format!{r"{open}{json_string}{close}"});

    if file != "" {fs::write(file, output.clone()).expect("Error when writing to file")} //Attempting to write localStorage command to file

    return output;

}
